// ********RoostGPT********
/*
Test generated by RoostGPT for test uploadfilespringboot using AI Type Open AI and AI Model gpt-4-turbo
ROOST_METHOD_HASH=getAverage_3b87df4523
ROOST_METHOD_SIG_HASH=getAverage_5d8b4919d3
Here are your existing test cases which we found out and are not considered for test generation:
File Path: /var/tmp/Roost/RoostGPT/uploadfilespringboot/1721820110/source/java-cucumber/src/test/java/br/masmangan/beecrowd/bee1005/StudentGradeSteps.java
Tests:
    "@Test
@When("average is calculated")
public void average_is_calculated() {
    actual = equation.getAverage();
}
"
File Path: /var/tmp/Roost/RoostGPT/uploadfilespringboot/1721820110/source/java-cucumber/src/test/java/br/masmangan/beecrowd/bee1006/StudentGradeSteps.java
Tests:
    "@Test
@When("average is calculated")
public void average_is_calculated() {
    actual = equation.getAverage();
}
"
Scenario 1: All coefficients are zero
Details:
  TestName: averageWithAllCoefficientsZero
  Description: Tests the method getAverage() when all private variables a, b, and c are set to zero. This scenario checks if the method correctly handles and returns zero as average when all inputs contribute no value.
Execution:
  Arrange: Set a, b, c to 0.0.
  Act: Call getAverage() to calculate the average.
  Assert: Assert that the returned average is 0.0.
Validation:
  The assertion verifies that the method correctly computes the average as zero when all weighted inputs are zero. This test is significant to confirm the method's behavior with the minimal boundary values of input coefficients.
Scenario 2: Positive coefficients
Details:
  TestName: averageWithPositiveCoefficients
  Description: Checks the average calculation when all private variables a, b, and c are positive. This helps to ensure that the method computes the weighted average correctly under normal conditions.
Execution:
  Arrange: Set a, b, c to positive values, for example, 1.0, 2.0, and 3.0 respectively.
  Act: Call getAverage() to calculate the average.
  Assert: Assert that the returned value matches the expected average calculated manually.
Validation:
  The assertion confirms that the method computes the correct weighted average when inputs are positive. It validates the correctness of the formula used in the method under typical usage conditions.
Scenario 3: Negative coefficients
Details:
  TestName: averageWithNegativeCoefficients
  Description: Tests how the method handles negative inputs for a, b, and c. This scenario is crucial for applications where negative values are valid and need to be averaged correctly.
Execution:
  Arrange: Set a, b, c to negative values, such as -1.0, -2.0, -3.0.
  Act: Call getAverage() to calculate the average.
  Assert: Assert that the computed average is as expected from the weighted sum of negative values.
Validation:
  Validates the method's ability to handle negative inputs accurately, confirming that the averaging formula correctly applies weights and sums up values, including negatives. This is important for comprehensive input handling.
Scenario 4: Mixed sign coefficients
Details:
  TestName: averageWithMixedSignCoefficients
  Description: Evaluates the getAverage() method's performance with a mix of positive and negative values for a, b, and c. It checks if the method can accurately compute the average in such cases.
Execution:
  Arrange: Set a to a negative value, b and c to positive values, e.g., -1.0, 2.0, 3.0.
  Act: Call getAverage() to calculate the average.
  Assert: Assert that the returned average is correctly calculated as per the formula.
Validation:
  This test confirms that the method can handle a mixture of negative and positive inputs, ensuring accurate computation. It's significant for scenarios where inputs may vary widely in sign and magnitude.
Scenario 5: Large coefficients
Details:
  TestName: averageWithLargeCoefficients
  Description: Tests the getAverage() method with very large values for a, b, and c to check for any overflow issues or inaccuracies in floating-point calculations.
Execution:
  Arrange: Set a, b, c to very large values, such as 1e6, 1e7, 1e8.
  Act: Call getAverage() to calculate the average.
  Assert: Assert that the returned average is close to the expected value, considering potential floating-point precision issues.
Validation:
  This test checks the method's robustness in handling large values, verifying that the calculations are performed accurately without overflow and within acceptable precision limits. It's crucial for high-range data scenarios.
*/
// ********RoostGPT********
package br.masmangan.beecrowd.bee1006;

import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.*;

@Tag("br.masmangan.beecrowd.bee1006")
@Tag("br.masmangan.beecrowd.bee1006.getAverage")
public class StudentGradeGetAverageTest {

	private StudentGradeGetAverage studentGrade;

	@BeforeEach
	public void setUp() {
		studentGrade = new StudentGradeGetAverage();
	}

	@Test
	public void averageWithAllCoefficientsZero() {
		studentGrade.a = 0.0;
		studentGrade.b = 0.0;
		studentGrade.c = 0.0;
		double expected = 0.0;
		double actual = studentGrade.getAverage();
		assertEquals(expected, actual, 0.0001);
	}

	@Test
	public void averageWithPositiveCoefficients() {
		studentGrade.a = 1.0;
		studentGrade.b = 2.0;
		studentGrade.c = 3.0;
		double expected = (1.0 * 2.0 + 2.0 * 3.0 + 3.0 * 5.0) / 10.0;
		double actual = studentGrade.getAverage();
		assertEquals(expected, actual, 0.0001);
	}

	@Test
	public void averageWithNegativeCoefficients() {
		studentGrade.a = -1.0;
		studentGrade.b = -2.0;
		studentGrade.c = -3.0;
		double expected = (-1.0 * 2.0 + -2.0 * 3.0 + -3.0 * 5.0) / 10.0;
		double actual = studentGrade.getAverage();
		assertEquals(expected, actual, 0.0001);
	}

	@Test
	public void averageWithMixedSignCoefficients() {
		studentGrade.a = -1.0;
		studentGrade.b = 2.0;
		studentGrade.c = 3.0;
		double expected = (-1.0 * 2.0 + 2.0 * 3.0 + 3.0 * 5.0) / 10.0;
		double actual = studentGrade.getAverage();
		assertEquals(expected, actual, 0.0001);
	}

	@Test
	public void averageWithLargeCoefficients() {
		studentGrade.a = 1e6;
		studentGrade.b = 1e7;
		studentGrade.c = 1e8;
		double expected = (1e6 * 2.0 + 1e7 * 3.0 + 1e8 * 5.0) / 10.0;
		double actual = studentGrade.getAverage();
		assertEquals(expected, actual, 0.0001);
	}

}